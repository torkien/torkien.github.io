---
layout:     post
title:      "Users Case Diagram"
subtitle:   " The first diagram of Unified Modeling Language"
date:       2016-11-21 2:00:00
author:     "Torkien"
header-img: "img/users-case-diagram.jpg"
tags:
    - UML
---

# 用例建模

## 组成

从用户的角度来看，他们并不想了解系统的内部结构和设计，他们所关心的是系统所能提供的服务，也就是被开发出来的系统将是如何被使用的，这就用例方法的基本思想。用例模型主要由以下模型元素构成： 

- **参与者(Actor):** 参与者是指存在于被定义系统外部并与该系统发生交互的人或其他系统，他们代表的是系统的使用者或使用环境。
- **用例(Use Case):** 
用例用于表示系统所提供的服务，它定义了系统是如何被参与者所使用的，它描述的是参与者为了使用系统所提供的某一完整功能而与系统之间发生的一段对话。
- **通讯关联(Communication Association):** 通讯关联用于表示参与者和用例之间的对应关系，它表示参与者使用了系统中的哪些服务（用例），或者说系统所提供的服务（用例）是被哪些参与者所使用的。
## 建模
使用用例的方法来描述系统的功能需求的过程就是用例建模，用例模型主要包括以下两部分内容：
- **用例图(Use Case Diagram) ：**确定系统中所包含的参与者、用例和两者之间的对应关系，用例图描述的是关于系统功能的一个概述。
- **用例规约(Use Case Specification) ；**针对每一个用例都应该有一个用例规约文档与之相对应，该文档描述用例的细节内容。

在用例建模的过程中，我们建议的步骤是先找出参与者，再根据参与者确定每个参与者相关的用例，最后再细化每一个用例的用例规约。

### 寻找参与者
所谓的参与者是指所有存在于系统外部并与系统进行交互的人或其他系统。通俗地讲，参与者就是我们所要定义系统的使用者。寻找参与者可以从以下问题入手：

- 系统开发完成之后，有哪些人会使用这个系统？
- 系统需要从哪些人或其他系统中获得数据？
- 系统会为哪些人或其他系统提供数据？
- 系统会与哪些其他系统相关联？
- 系统是由谁来维护和管理的？

这些问题有助于我们抽象出系统的参与者。对于ATM机的例子，回答这些问题可以使我们找到更多的参与者：操作员负责维护和管理ATM机系统、ATM机也需要与后台服务器进行通讯以获得有关用户帐号的相关信息。

#### 系统边界决定了参与者
参与者是由系统的边界所决定的，如果我们所要定义的系统边界仅限于ATM机本身，那么后台服务器就是一个外部的系统，可以抽象为一个参与者。

如果我们所要定义的系统边界扩大至整个银行系统，ATM机和后台服务器都是整个银行系统的一部分，这时候后台服务器就不再被抽象成为一个参与者。

值得注意的是，用例建模时不要将一些系统的组成结构作为参与者来进行抽象，如在ATM机系统中，打印机只是系统的一个组成部分，不应将它抽象成一个独立的参与者；在一个MIS管理系统中，数据库系统往往只作为系统的一个组成部分，一般不将其单独抽象成一个参与者。

#### 特殊的参与者――系统时钟
有时候我们需要在系统内部定时地执行一些操作，如检测系统资源使用情况、定期地生成统计报表等等。从表面上看，这些操作并不是由外部的人或系统触发的，应该怎样用用例方法来表述这一类功能需求呢？对于这种情况，我们可以抽象出一个系统时钟或定时器参与者，利用该参与者来触发这一类定时操作。从逻辑上，这一参与者应该被理解成是系统外部的，由它来触发系统所提供的用例对话。

### 确定用例
找到参与者之后，我们就可以根据参与者来确定系统的用例，主要是看各参与者需要系统提供什么样的服务，或者说参与者是如何使用系统的。寻找用例可以从以下问题入手（针对每一个参与者）：

- 参与者为什么要使用该系统？
- 参与者是否会在系统中创建、修改、删除、访问、存储数据？如果是的话，参与者又是如何来完成这些操作的？
- 参与者是否会将外部的某些事件通知给该系统？
- 系统是否会将内部的某些事件通知该参与者？

#### 注意：

 - **用例必须是由某一个主角触发而产生的活动，即每个用例至少应该涉及一个主角。**
 如果存在与主角不进行交互的用例，就可以考虑将其并入其他用例；或者是检查该用例相对应的参与者是否被遗漏，如果是，则补上该参与者。反之，每个参与者也必须至少涉及到一个用例，如果发现有不与任何用例相关联的参与者存在，就应该考虑该参与者是如何与系统发生对话的，或者由参与者确定一个新的用例，或者该参与者是一个多余的模型元素，应该将其删除。

- **可视化建模的主要目的之一就是要增强团队的沟通，用例模型必须是易于理解的。**
用例建模往往是一个团队开发的过程，系统分析员在建模过程中必须注意参与者和用例的名称应该符合一定的命名约定，这样整个用例模型才能够符合一定的风格。如参与者的名称一般都是名词，用例名称一般都是动宾词组等。

- **对于同一个系统，不同的人对于参与者和用例都可能有不同的抽象结果，因而得到不同的用例模型。**
我们需要在多个用例模型方案中选择一种"最佳"（或"较佳"）的结果，一个好的用例模型应该能够容易被不同的涉众所理解，并且不同的涉众对于同一用例模型的理解应该是一致的。

###	描述用例规约

**应该避免这样一种误解――认为由参与者和用例构成的用例图就是用例模型**，用例图只是在总体上大致描述了系统所能提供的各种服务，让我们对于系统的功能有一个总体的认识。除此之外，我们还需要描述每一个有例的详细信息，这些信息包含在用例规约中，用例模型是由用例图和每一个用例的详细描述――用例规约所组成的。每一个用例的用例规约都应该包含以下内容：

- **简要说明 (Brief Description)：** 简要介绍该用例的作用和目的。
- **事件流 (Flow of Event)：** 包括基本流和备选流，事件流应该表示出所有的场景。
- **用例场景 (Use-Case Scenario) ：**包括成功场景和失败场景，场景主要是由基本流和备选流组合而成的。
- **特殊需求 (Special Requirement) ：**描述与该用例相关的非功能性需求（包括性能、可靠性、可用性和可扩展性等）和设计约束（所使用的操作系统、开发工具等）。
- **前置条件 (Pre-Condition) ：**执行用例之前系统必须所处的状态。
- **后置条件 (Post-Condition) ：**用例执行完毕后系统可能处于的一组状态。

用例规约基本上是用**文本方式**来表述的，为了更加清晰地描述事件流，也可以选择使用**状态图、活动图或序列图**来辅助说明。只要有助于表达的简洁明了，就可以在用例中任意粘贴用户界面和流程的图形化显示方式，或是其他图形。
- **活动图：**有助于描述复杂的决策流程
- **状态图：**有助于描述与状态相关的系统行为
- **序列图：**适合于描述基于时间顺序的消息传递

#### 基本流
基本流描述的是该用例最正常的一种场景，在基本流中系统执行一系列活动步骤来响应参与者提出的服务请求。我们建议用以下格式来描述基本流：

- 每一个步骤都需要用数字编号以清楚地标明步骤的先后顺序。	
- 用一句简短的标题来概括每一步骤的主要内容，这样阅读者可以通过浏览标题来快速地了解用例的主要步骤。在用例建模的早期，我们也只需要描述到事件流步骤标题这一层，以免过早地陷入到用例描述的细节中去。
-	当整个用例模型基本稳定之后，我们再针对每一步骤详细描述参与者和系统之间所发生的交互。建议采用双向(roundtrip)描述法来保证描述的完整性，即每一步骤都需要从正反两个方面来描述:(1)参与者向系统提交了什么信息；(2)对此系统有什么样的响应。
- 在描述参与者和系统之间的信息交换时，需指出来回传递的具体信息。例如，只表述参与者输入了客户信息就不够明确，最好明确地说参与者输入了客户姓名和地址。通常可以利用词汇表让用例的复杂性保持在可控范围内，可以在词汇表中定义客户信息等内容，使用例不至于陷入过多的细节。
####备选流
备选流负责描述用例执行过程中异常的或偶尔发生的一些情况，备选流和基本流的组合应该能够覆盖该用例所有可能发生的场景。在描述备选流时，应该包括以下几个要素：
	-   **起点：**该备选流从事件流的哪一步开始；
	- 	**条件：**在什么条件下会触发该备选流；
	-	**动作：**系统在该备选流下会采取哪些动作；
	-	**恢复：**该备选流结束之后，该用例应如何继续执行。

备选流的描述格式可以与基本流的格式一致，也需要编号并以标题概述其内容，编号前可以加以字母前缀A(Alternative)以示与基本流步骤相区别。

#### 用例场景
**用例在实际执行的时候会有很多的不同情况发生，称之为用例场景；**也可以说场景是用例的实例，我们在描述用例的时候要覆盖所有的用例场景，否则就有可能导致需求的遗漏。在用例规约中，场景的描述可以由基本流和备选流的组合来表示。场景既可以帮助我们防止需求的遗漏，同时也可以对后续的开发工作起到很大的帮助：开发人员必须实现所有的场景、测试人员可以根据用例场景来设计测试用例。

#### 特殊需求

**特殊需求通常是非功能性需求，它为一个用例所专有，但不适合在用例的事件流文本中进行说明。**特殊需求的例子包括法律或法规方面的需求、应用程序标准和所构建系统的质量属性（包括可用性、可靠性、性能或支持性需求等）。此外，其他一些设计约束，如操作系统及环境、兼容性需求等，也可以在此节中记录。
需要注意的是，这里记录的是专属于该用例的特殊需求；对于一些全局的非功能性需求和设计约束，它们并不是该用例所专有的，应把它们记录在《补充规约》中。

#### 前置和后置条件
前置条件是执行用例之前必须存在的系统状态，后置条件是用例一执行完毕后系统可能处于的一组状态。

### 检查用例模型

用例模型完成之后，可以对用例模型进行检查，看看是否有遗漏或错误之处。主要可以从以下几个方面来进行检查：

- **功能需求的完备性 :** 现有的用例模型是否完整地描述了系统功能，这也是我们判断用例建模工作是否结束的标志。如果发现还有系统功能没有被记录在现有的用例模型中，那么我们就需要抽象一些新的用例来记录这些需求，或是将他们归纳在一些现有的用例之中。
- **模型是否易于理解 :**用例模型最大的优点就在于它应该易于被不同的涉众所理解，因而用例建模最主要的指导原则就是它的可理解性。用例的粒度、个数以及模型元素之间的关系复杂程度都应该由该指导原则决定。
- **是否存在不一致性 :**系统的用例模型是由多个系统分析员协同完成的，模型本身也是由多个工件所组成的，所以我们要特别注意不同工件之前是否存在前后矛盾或冲突的地方，避免在模型内部产生不一致性。不一致性会直接影响到需求定义的准确性。
- **避免二义性语义:** 好的需求定义应该是无二义性的，即不同的人对于同一需求的理解应该是一致的。在用例规约的描述中，应该避免定义含义模糊的需求，即无二义性。

## 系统需求
RUP中根据FURPS+模型将系统需求分为以下几类：

- 功能(Functionality)
- 可用性(Usability)
- 可靠性(Reliability)
- 性能(Performance)
- 可支持性(Supportability)
- 设计约束等

除了第一项功能性需求之外的其他需求都归之为非功能性需求。

### 需求工件集
用例模型主要用于描述系统的功能性需求，对于其他的非功能性需要用其他文档来记录。RUP中定义了如下的需求工件集合。

- **用例模型：**记录功能性需求
- **用例图：**描述参与者和用例之间的关系
- **用例规约：**描述每一个用例的细节信息
- **补充规约：**记录一些全局性的功能需求、非功能性需求和设计约束等
- **词汇表：**记录一些系统需求相关的术语

在实际应用中，除了这些工件之外，我们还可以根据实际需求灵活选用其他形式的文档来补充说明需求。并不是所有的系统需求都适保合用用例模型来描述的，如编译器，我们很难用用例方法来表述它所处理的语言的方法规则，在这种情况下，采用传统的BNF范式来表述更加合适一些。万万不可拘泥于用例建模的形式，应灵活运用各种方式的长处。

### 补充规约
补充规约记录那些在用例模型中不易表述的系统需求，主要包括以下内容。

- **功能性 ：**功能性需求主要在用例模型中刻画，但是也有部分需求不适合在用例中表述。有些功能性需求是全局性的，适用于所有的用例，如出错处理、I18N支持等，我们不需要在所有的用例中描述这些功能性需求，只需要在补充规约中统一描述就可以了。
- **可用性：**记录所有可用性相关的需求，如系统的使用者所需要的培训时间、是否应附合一些常见的可用性标准如Windows界面风格等。
- **可靠性：**定义系统可靠性相关的各种指标，包括： 
- **可用性：**指出可用时间百分比(xx.xx%)，系统处于使用、维护、降级模式等操作的小时数；
平均故障间隔时间(MTBF)：通常表示为小时数，但也可表示为天数、月数或年数；
平均修复时间(MTTR)：系统在发生故障后可以暂停运行的时间；
- **精确度：**指出系统输出要求具备的精密度（分辨率）和精确度（按照某一已知的标准）；
最高错误或缺陷率：通常表示为bugs/KLOC（每千行代码的错误数目）或bugs/function-point（每个功能点的错误数目）。
- **性能:**记录系统性能相关的各种指标，包括： 
- 对事务的响应时间（平均、最长）；
- 吞吐量（例如每秒处理的事务数）；
- 容量（例如系统可以容纳的客户或事务数）；
- 降级模式（当系统以某种形式降级时可接受的运行模式）；

- **资源利用情况：**内存、磁盘、通信等。
- **可支持性：**定义所有与系统的可支持性或可维护性相关的需求，其中包括编码标准、命名约定、类库、如何来对系统进行维护操作和相应的维护实用工具等。
- **设计约束：**设计约束代表已经批准并必须遵循的设计决定，其中包括软件开发流程、开发工具、系统构架、编程语言、第三方构件类库、运行平台和数据库系统等等。

### 词汇表
词汇表主要用于定义项目特定的术语，它有助于开发人员对项目中所用的术语有统一的理解和使用，它也是后续阶段中进行对象抽象的基础。